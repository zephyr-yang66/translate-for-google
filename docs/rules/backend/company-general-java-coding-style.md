---
level: 00
description: 邦道科技 - 公司级通用 Java 编码规范。
globs: **/*.{java,sql,xml,sql}
---

## 一、编程规约

### (一) 命名风格

1.【强制】所有编程相关的命名均不能以下划线或美元符号开始，也不能以下划线或美元符号结束。
2.【强制】所有编程相关的命名严禁使用拼音与英文混合的方式，更不允许直接使用中文的方式。
3.【强制】代码和注释中都要避免使用任何人类语言中的种族歧视性或侮辱性词语。
4.【强制】类名使用 UpperCamelCase 风格，以下情形例外：DO / PO / DTO / BO / VO / UID 等。
5.【强制】方法名、参数名、成员变量、局部变量都统一使用 lowerCamelCase 风格。
6.【强制】常量命名应该全部大写，单词间用下划线隔开，力求语义表达完整清楚，不要嫌名字长。
7.【强制】抽象类命名使用 Abstract 或 Base 开头；异常类命名使用 Exception 结尾，测试类命名以它要测试的类的名称开始，以 Test 结尾。
8.【强制】类型与中括号紧挨相连来定义数组。
9.【强制】POJO 类中的任何布尔类型的变量，都不要加 is 前缀，否则部分框架解析会引起序列化错误。
10.【强制】包名统一使用小写，点分隔符之间有且仅有一个自然语义的英语单词。包名统一使用单数形式，但是类名如果有复数含义，类名可以使用复数形式。
11.【强制】避免在子父类的成员变量之间、或者不同代码块的局部变量之间采用完全相同的命名，使可理解性降低。
12.【强制】杜绝完全不规范的英文缩写，避免望文不知义。
13.【强制】对于 Service 和 DAO 类，基于 SOA 的理念，暴露出来的服务一定是接口，内部的实现类用 Impl 的后缀与接口区别。

### (二) 常量定义

1.【强制】不允许任何魔法值（即未经预先定义的常量）直接出现在代码中。
2.【强制】long 或 Long 赋值时，数值后使用大写 L，不能是小写 l，小写容易跟数字混淆，造成误解。
3.【强制】浮点数类型的数值后缀统一为大写的 D 或 F。

### (三) 代码格式

1.【强制】如果大括号内为空，简洁地写成{}即可，大括号中间无需换行和空格；如果是非空代码块，则：
   1）左大括号前不换行。
   2）左大括号后换行。
   3）右大括号前换行。
   4）右大括号后还有 else 等代码则不换行；表示终止的右大括号后必须换行。
2.【强制】左小括号和右边相邻字符之间不需要空格；右小括号和左边相邻字符之间也不需要空格；而左大括号前需要加空格。
3.【强制】if / for / while / switch / do 等保留字与左右括号之间都必须加空格。
4.【强制】任何二目、三目运算符的左右两边都需要加一个空格。
5.【强制】采用 4 个空格缩进，禁止使用 Tab 字符。
6.【强制】注释的双斜线与注释内容之间有且仅有一个空格。
7.【强制】在进行类型强制转换时，右括号与强制转换值之间不需要任何空格隔开。
8.【强制】单行字符数限制不超过 120 个，超出需要换行，换行时遵循如下原则：
   1）第二行相对第一行缩进 4 个空格，从第三行开始，不再继续缩进，参考示例。
   2）运算符与下文一起换行。
   3）方法调用的点符号与下文一起换行。
   4）方法调用中的多个参数需要换行时，在逗号后进行。
   5）在括号前不要换行。
9.【强制】方法参数在定义和传入时，多个参数逗号后面必须加空格。
10.【强制】IDE 的 text file encoding 设置为 UTF-8；IDE 中文件的换行符使用 Unix 格式，不要使用Windows 格式。

### (四) OOP 规约

1.【强制】避免通过一个类的对象引用访问此类的静态变量或静态方法，无谓增加编译器解析成本，直接用类名来访问即可。
2.【强制】所有的覆写方法，必须加 @Override 注解。
3.【强制】相同参数类型，相同业务含义，才可以使用的可变参数，参数类型避免定义为 Object。
4.【强制】外部正在调用的接口或者二方库依赖的接口，不允许修改方法签名，避免对接口调用方产生影响。接口过时必须加 @Deprecated 注解，并清晰地说明采用的新接口或者新服务是什么。
5.【强制】不能使用过时的类或方法。
6.【强制】Object 的 equals 方法容易抛空指针异常，应使用常量或确定有值的对象来调用 equals。
7.【强制】所有整型包装类对象之间值的比较，全部使用 equals 方法比较。
8.【强制】任何货币金额，均以最小货币单位且为整型类型进行存储。
9.【强制】浮点数之间的等值判断，基本数据类型不能使用 == 进行比较，包装数据类型不能使用 equals 进行判断。
10.【强制】BigDecimal 的等值比较应使用 compareTo() 方法，而不是 equals() 方法。
11.【强制】定义数据对象 DO 类时，属性类型要与数据库字段类型相匹配。
12.【强制】禁止使用构造方法 BigDecimal(double) 的方式把 double 值转化为 BigDecimal 对象。
13.【强制】关于基本数据类型与包装数据类型的使用标准如下：
    1）所有的 POJO 类属性必须使用包装数据类型。
    2）RPC 方法的返回值和参数必须使用包装数据类型。
14.【强制】定义 DO / PO / DTO / VO 等 POJO 类时，不要设定任何属性默认值。
15.【强制】序列化类新增属性时，请不要修改 serialVersionUID 字段，避免反序列失败；如果完全不兼容升级，避免反序列化混乱，那么请修改 serialVersionUID 值。
16.【强制】构造方法里面禁止加入任何业务逻辑，如果有初始化逻辑，请放在 init 方法中。
17.【强制】POJO 类必须写 toString 方法。使用 IDE 中的工具 source > generate toString 时，如果继承了另一个 POJO 类，注意在前面加一下 super.toString()。
18.【强制】禁止在 POJO 类中，同时存在对应属性 xxx 的 isXxx() 和 getXxx() 方法。

### (五) 日期时间

1.【强制】日期格式化时，传入 pattern 中表示年份统一使用小写的 y。
2.【强制】在日期格式中分清楚大写的 M 和小写的 m，大写的 H 和小写的 h 分别指代的意义。
3.【强制】获取当前毫秒数：System.currentTimeMillis()；而不是 new Date().getTime()。
4.【强制】不允许在程序任何地方中使用：1）java.sql.Date  2）java.sql.Time  3）java.sql.Timestamp。
5.【强制】禁止在程序中写死一年为 365 天，避免在公历闰年时出现日期转换错误或程序逻辑错误。

### (六) 集合处理

1.【强制】关于 hashCode 和 equals 的处理，遵循如下规则：
   1）只要覆写 equals，就必须覆写 hashCode。
   2）因为 Set 存储的是不重复的对象，依据 hashCode 和 equals 进行判断，所以 Set 存储的对象必须覆写这两种方法。
   3）如果自定义对象作为 Map 的键，那么必须覆写 hashCode 和 equals。
2.【强制】判断所有集合内部的元素是否为空，使用 isEmpty() 方法，而不是 size() == 0 的方式。
3.【强制】在使用 java.util.stream.Collectors 类的 toMap() 方法转为 Map 集合时，一定要使用参数类型为 BinaryOperator，参数名为 mergeFunction 的方法，否则当出现相同 key 时会抛出 IllegalStateException 异常。
4.【强制】在使用 java.util.stream.Collectors 类的 toMap() 方法转为 Map 集合时，一定要注意当 value 为 null 时会抛 NPE 异常。
5.【强制】ArrayList 的 subList 结果不可强转成 ArrayList，否则会抛出 ClassCastException 异常。
6.【强制】使用 Map 的方法 keySet() / values() / entrySet() 返回集合对象时，不可以对其进行添加元素操作，否则会抛出 UnsupportedOperationException 异常。
7.【强制】Collections 类返回的对象，如：emptyList() / singletonList() 等都是 immutable list，不可对其进行添加或者删除元素的操作。
8.【强制】在 subList 场景中，高度注意对父集合元素的增加或删除，均会导致子列表的遍历、增加、删除产生 ConcurrentModificationException 异常。
9.【强制】使用集合转数组的方法，必须使用集合的 toArray(T[] array)，传入的是类型完全一致、长度为 0 的空数组。
10.【强制】使用 Collection 接口任何实现类的 addAll() 方法时，要对输入的集合参数进行 NPE 判断。
11.【强制】使用工具类 Arrays.asList() 把数组转换成集合时，不能使用其修改集合相关的方法，它的 add / remove / clear 方法会抛出 UnsupportedOperationException 异常。
12.【强制】泛型通配符<? extends T>来接收返回的数据，此写法的泛型集合不能使用 add 方法，而<? super T>不能使用 get 方法，两者在接口调用赋值的场景中容易出错。
13.【强制】在无泛型限制定义的集合赋值给泛型限制的集合时，在使用集合元素时，需要进行 instanceof 判断，避免抛出 ClassCastException 异常。
14.【强制】不要在 foreach 循环里进行元素的 remove / add 操作。remove 元素请使用 iterator 方式，如果并发操作，需要对 iterator 对象加锁。
15.【强制】在 JDK7 版本及以上，Comparator 实现类要满足如下三个条件，不然 Arrays.sort，Collections.sort 会抛 IllegalArgumentException 异常。
    1）x，y 的比较结果和 y，x 的比较结果相反。
    2）x > y，y > z，则 x > z。
    3）x = y，则 x，z 比较结果和 y，z 比较结果相同。

### (七) 并发处理

1.【强制】获取单例对象需要保证线程安全，其中的方法也要保证线程安全。
2.【强制】创建线程或线程池时请指定有意义的线程名称，方便出错时回溯。
3.【强制】线程资源必须通过线程池提供，不允许在应用中自行显式创建线程。
4.【强制】线程池不允许使用 Executors 去创建，而是通过 ThreadPoolExecutor 的方式，这样的处理方式让写的同学更加明确线程池的运行规则，规避资源耗尽的风险。
5.【强制】SimpleDateFormat 是线程不安全的类，一般不要定义为 static 变量，如果定义为 static，必须加锁，或者使用 DateUtils 工具类。
6.【强制】必须回收自定义的 ThreadLocal 变量记录的当前线程的值，尤其在线程池场景下，线程经常会被复用，如果不清理自定义的 ThreadLocal 变量，可能会影响后续业务逻辑和造成内存泄露等问题。尽量在代码中使用 try-finally 块进行回收。
7.【强制】高并发时，同步调用应该去考量锁的性能损耗。能用无锁数据结构，就不要用锁；能锁区块，就不要锁整个方法体；能用对象锁，就不要用类锁。
8.【强制】对多个资源、数据库表、对象同时加锁时，需要保持一致的加锁顺序，否则可能会造成死锁。
9.【强制】在使用阻塞等待获取锁的方式中，必须在 try 代码块之外，并且在加锁方法与 try 代码块之间没有任何可能抛出异常的方法调用，避免加锁成功后，在 finally 中无法解锁。
10.【强制】在使用尝试机制来获取锁的方式中，进入业务代码块之前，必须先判断当前线程是否持有锁。锁的释放规则与锁的阻塞等待方式相同。
11.【强制】并发修改同一记录时，避免更新丢失，需要加锁。要么在应用层加锁，要么在缓存加锁，要么在数据库层使用乐观锁，使用 version 作为更新依据。
12.【强制】多线程并行处理定时任务时，Timer 运行多个 TimeTask 时，只要其中之一没有捕获抛出的异常，其它任务便会自动终止运行，使用 ScheduledExecutorService 则没有这个问题。

### (八) 控制语句

1.【强制】在一个 switch 块内，每个 case 要么通过 continue / break / return 等来终止，要么注释说明程序将继续执行到哪一个 case 为止；在一个 switch 块内，都必须包含一个 default 语句并且放在最后，即使它什么代码也没有。
2.【强制】当 switch 括号内的变量类型为 String 并且此变量为外部参数时，必须先进行 null 判断。
3.【强制】在 if / else / for / while / do 语句中必须使用大括号。
4.【强制】三目运算符 condition ? 表达式 1：表达式 2 中，高度注意表达式 1 和 2 在类型对齐时，可能抛出因自动拆箱导致的 NPE 异常。
5.【强制】在高并发场景中，避免使用"等于"判断作为中断或退出的条件。

### (九) 注释规约

1.【强制】类、类属性、类方法的注释必须使用 Javadoc 规范，使用 /** 内容 */ 格式，不得使用 // xxx 方式。
2.【强制】所有的抽象方法（包括接口中的方法）必须要用 Javadoc 注释、除了返回值、参数异常说明外，还必须指出该方法做什么事情，实现什么功能。
3.【强制】所有的类都必须添加创建者和创建日期。
4.【强制】方法内部单行注释，在被注释语句上方另起一行，使用 // 注释。方法内部多行注释使用 /*  */ 注释，注意与代码对齐。
5.【强制】所有的枚举类型字段必须要有注释，说明每个数据项的用途。

### (十) 前后端规约

1.【强制】前后端交互的 API，需要明确协议、域名、路径、请求方法、请求内容、状态码、响应体。
2.【强制】前后端数据列表相关的接口返回，如果为空，则返回空数组[]或空集合{}。
3.【强制】服务端发生错误时，返回给前端的响应信息必须包含 HTTP 状态码，errorCode、errorMessage、用户提示信息四个部分。
4.【强制】在前后端交互的 JSON 格式数据中，所有的 key 必须为小写字母开始的 lowerCamelCase 风格，符合英文表达习惯，且表意完整。
5.【强制】errorMessage 是前后端错误追踪机制的体现，可以在前端输出到 type="hidden" 文字类控件中，或者用户端的日志中，帮助我们快速地定位出问题。
6.【强制】对于需要使用超大整数的场景，服务端一律使用 String 字符串类型返回，禁止使用 Long 类型。
7.【强制】HTTP 请求通过 URL 传递参数时，不能超过 2048 字节。
8.【强制】HTTP 请求通过 body 传递内容时，必须控制长度，超出最大长度后，后端解析会出错。
9.【强制】在翻页场景中，用户输入参数的小于 1，则前端返回第一页参数给后端；后端发现用户输入的参数大于总页数，直接返回最后一页。
10.【强制】服务器内部重定向必须使用 forward；外部重定向地址必须使用 URL 统一代理模块生成，否则会因线上采用 HTTPS 协议而导致浏览器提示"不安全"，并且还会带来 URL 维护不一致的问题。

### (十一) 其他

1.【强制】在使用正则表达式时，利用好其预编译功能，可以有效加快正则匹配速度。
2.【强制】避免任何三方库的属性拷贝工具如BeanUtils，你应该直接使用 getter/setter 方法赋值。
3.【强制】velocity 调用 POJO 类的属性时，直接使用属性名取值即可，模板引擎会自动按规范调用 POJO 的 getXxx()，如果是 boolean 基本数据类型变量（boolean 命名不需要加 is 前缀），会自动调 isXxx() 方法。
4.【强制】后台输送给页面的变量必须加 $!{var} ——中间的感叹号。
5.【强制】注意 Math.random() 这个方法返回是 double 类型，注意取值的范围 0 ≤ x < 1（能够取到零值，注意除零异常），如果想获取整数类型的随机数，不要将 x 放大 10 的若干倍然后取整，直接使用 Random 对象的 nextInt 或者 nextLong 方法。
6.【强制】枚举 enum（括号内）的属性字段必须是私有且不可变。

## 二、异常日志

### (一) 异常处理

1.【强制】Java 类库中定义的可以通过预检查方式规避的 RuntimeException 异常不应该通过 catch 的方式来处理，比如：NullPointerException，IndexOutOfBoundsException 等等。
2.【强制】异常捕获后不要用来做流程控制，条件控制。
3.【强制】catch 时请分清稳定代码和非稳定代码，稳定代码指的是无论如何不会出错的代码。对于非稳定代码的 catch 尽可能进行区分异常类型，再做对应的异常处理。
4.【强制】捕获异常是为了处理它，不要捕获了却什么都不处理而抛弃之，如果不想处理它，请将该异常抛给它的调用者。最外层的业务使用者，必须处理异常，将其转化为用户可以理解的内容。
5.【强制】事务场景中，抛出异常被 catch 后，如果需要回滚，一定要注意手动回滚事务。
6.【强制】finally 块必须对资源对象、流对象进行关闭，有异常也要做 try-catch。
7.【强制】不要在 finally 块中使用 return。
8.【强制】捕获异常与抛异常，必须是完全匹配，或者捕获异常是抛异常的父类。
9.【强制】在调用 RPC、二方包、或动态生成类的相关方法时，捕捉异常使用 Throwable 类进行拦截。

### (二) 日志规约

1.【强制】应用中不可直接使用日志系统（Log4j、Logback）中的 API，而应依赖使用日志框架（SLF4J、JCL—Jakarta Commons Logging）中的 API，使用门面模式的日志框架，有利于维护和各个类的日志处理方式统一。
2.【强制】日志文件至少保存 15 天，因为有些异常具备以"周"为频次发生的特点。对于当天日志，以"应用名.log"来保存，保存在/{统一目录}/{应用名}/logs/目录下，过往日志格式为：{logname}.log.{保存日期}，日期格式：yyyy-MM-dd
3.【强制】根据国家法律，网络运行状态、网络安全事件、个人敏感信息操作等相关记录，留存的日志不少于六个月，并且进行网络多机备份。
4.【强制】应用中的扩展日志（如打点、临时监控、访问日志等）命名方式：appName_logType_logName.log。logType：日志类型，如 stats / monitor / access 等；logName：日志描述。这种命名的好处：通过文件名就可知道日志文件属于什么应用，什么类型，什么目的，也有利于归类查找。
5.【强制】在日志输出时，字符串变量之间的拼接使用占位符的方式。
6.【强制】对于 trace / debug / info 级别的日志输出，必须进行日志级别的开关判断。
7.【强制】避免重复打印日志，浪费磁盘空间，务必在日志配置文件中设置 additivity=false。
8.【强制】生产环境禁止使用 System.out 或 System.err 输出或使用 e.printStackTrace() 打印异常堆栈。
9.【强制】异常信息应该包括两类信息：案发现场信息和异常堆栈信息。如果不处理，那么通过关键字 throws 往上抛出。
10.【强制】日志打印时禁止直接用 JSON 工具将对象转换成 String。

## 三、单元测试

1.【强制】好的单元测试必须遵守 AIR 原则。
2.【强制】单元测试应该是全自动执行的，并且非交互式的。测试用例通常是被定期执行的，执行过程必须完全自动化才有意义。输出结果需要人工检查的测试不是一个好的单元测试。不允许使用 System.out 来进行人肉验证，单元测试必须使用 assert 来验证。
3.【强制】保持单元测试的独立性。为了保证单元测试稳定可靠且便于维护，单元测试用例之间决不能互相调用，也不能依赖执行的先后次序。
4.【强制】单元测试是可以重复执行的，不能受到外界环境的影响。
5.【强制】对于单元测试，要保证测试粒度足够小，有助于精确定位问题。单测粒度至多是类级别，一般是方法级别。
6.【强制】核心业务、核心应用、核心模块的增量代码确保单元测试通过。
7.【强制】单元测试代码必须写在如下工程目录： src/test/java，不允许写在业务代码目录下。

## 四、安全规约

1.【强制】隶属于用户个人的页面或者功能必须进行权限控制校验。
2.【强制】用户敏感数据禁止直接展示，必须对展示数据进行脱敏。
3.【强制】用户输入的 SQL 参数严格使用参数绑定或者 METADATA 字段值限定，防止 SQL 注入，禁止字符串拼接 SQL 访问数据库。
4.【强制】用户请求传入的任何参数必须做有效性验证。
5.【强制】禁止向 HTML 页面输出未经安全过滤或未正确转义的用户数据。
6.【强制】表单、AJAX 提交必须执行 CSRF 安全验证。
7.【强制】URL 外部重定向传入的目标地址必须执行白名单过滤。
8.【强制】在使用平台资源，譬如短信、邮件、电话、下单、支付，必须实现正确的防重放的机制，如数量限制、疲劳度控制、验证码校验，避免被滥刷而导致资损。
9.【强制】对于文件上传功能，需要对于文件大小、类型进行严格检查和控制。
10.【强制】配置文件中的密码需要加密。

## 五、MySQL 数据库

### (一) 建表规约

1.【强制】表达是与否概念的字段，必须使用 is_xxx 的方式命名，数据类型是 unsigned tinyint（1 表示是，0 表示否）。
2.【强制】表名、字段名必须使用小写字母或数字，禁止出现数字开头禁止两个下划线中间只出现数字。数据库字段名的修改代价很大，因为无法进行预发布，所以字段名称需要慎重考虑。
3.【强制】表名不使用复数名词。
4.【强制】禁用保留字，如 desc、range、match、delayed 等，请参考 MySQL 官方保留字。
5.【强制】主键索引名为 pk_字段名；唯一索引名为 uk_字段名；普通索引名则为 idx_字段名。
6.【强制】小数类型为 decimal，禁止使用 float 和 double。
7.【强制】如果存储的字符串长度几乎相等，使用 char 定长字符串类型。
8.【强制】varchar 是可变长字符串，不预先分配存储空间，长度不要超过 5000，如果存储长度大于此值，定义字段类型为 text，独立出来一张表，用主键来对应，避免影响其它字段索引率。
9.【强制】表必备三字段：id，create_time，update_time。
10.【强制】在数据库中不能使用物理删除操作，要使用逻辑删除。

### (二) 索引规约

1.【强制】业务上具有唯一特性的字段，即使是组合字段，也必须建成唯一索引。
2.【强制】超过三个表禁止 join。需要 join 的字段，数据类型保持绝对一致；多表关联查询时，保证被关联的字段需要有索引。
3.【强制】在 varchar 字段上建立索引时，必须指定索引长度，没必要对全字段建立索引，根据实际文本区分度决定索引长度。
4.【强制】页面搜索严禁左模糊或者全模糊，如果需要请走搜索引擎来解决。

### (三) SQL 语句

1.【强制】不要使用 count(列名) 或 count(常量) 来替代 count(*)，count(*) 是 SQL92 定义的标准统计行数的语法，跟数据库无关，跟 NULL 和非 NULL 无关。
2.【强制】count(distinct col) 计算该列除 NULL 之外的不重复行数，注意 count(distinct col1 , col2) 如果其中一列全为 NULL，那么即使另一列有不同的值，也返回为 0。
3.【强制】当某一列的值全是 NULL 时，count(col) 的返回结果为 0；但 sum(col) 的返回结果为 NULL，因此使用 sum() 时需注意 NPE 问题。
4.【强制】使用 ISNULL() 来判断是否为 NULL 值。
5.【强制】代码中写分页查询逻辑时，若 count 为 0 应直接返回，避免执行后面的分页语句。
6.【强制】不得使用外键与级联，一切外键概念必须在应用层解决。
7.【强制】禁止使用存储过程，存储过程难以调试和扩展，更没有移植性。
8.【强制】数据订正（特别是删除或修改记录操作）时，要先 select，避免出现误删除的情况，确认无误才能执行更新语句。
9.【强制】对于数据库中表记录的查询和变更，只要涉及多个表，都需要在列名前加表的别名（或表名）进行限定。

### (四) ORM 映射

1.【强制】在表查询中，一律不要使用 * 作为查询的字段列表，需要哪些字段必须明确写明。
2.【强制】POJO 类的布尔属性不能加 is，而数据库字段必须加 is_，要求在 resultMap 中进行字段与属性之间的映射。
3.【强制】不要用 resultClass 当返回参数，即使所有类属性名与数据库字段一一对应，也需要定义<resultMap>；反过来，每一个表也必然有一个<resultMap>与之对应。
4.【强制】sql.xml 配置参数使用：#{}，#param# 不要使用 ${} 此种方式容易出现 SQL 注入。
5.【强制】iBATIS 自带的 queryForList(String statementName，int start，int size) 不推荐使用。
6.【强制】不允许直接拿 HashMap 与 Hashtable 作为查询结果集的输出。
7.【强制】更新数据表记录时，必须同时更新记录对应的 update_time 字段值为当前时间。